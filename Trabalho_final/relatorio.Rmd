---
title: ""
output: pdf_document
indent: true
header-includes:
    - \usepackage{caption}
    - \usepackage{indentfirst}
---

```{r setup, include = FALSE, warning = FALSE}
library(ggplot2)
library(ggtext)
library(latex2exp)
library(survival)
library(kableExtra)
library(cowplot)
knitr::opts_chunk$set(echo = F, fig.height=4, fig.width=6,comment=NA,fig.align='center')
```


\large \begin{center}
	\textbf{UNIVERSIDADE FEDERAL DO RIO DE JANEIRO}\\
	
Instituto de Matemática\\

Análise de Sobrevivência\\

\vspace{250 pt}

\textbf{{\Large Relatório do trabalho final}}\\

\vspace{160 pt}
\begin{flushright}

	\textbf{Alunos:}\text{ Daniel Barreto}\\
	                \text{ Renan Reis}\\
	                \text{ Silvaneo Junior}\\
	\textbf{Professora:}\text{ Marina Silva Paez}\\
	
\end{flushright}
\vspace{90 pt}

Rio de Janeiro, 7 de outubro de 2021.

\end{center}

\pagebreak

# 1 - Introdução

\vspace{10 pt}

Este trabalho consiste na construção e avaliação de modelos para análise de sobrevivência em um conjunto de dados referentes aos clientes de uma companhia de telecomunicações, sendo este conjunto disponibilizado pela *IBM*. Os dados utilizados foram gerados artificialmente por parte da *IBM*, desta forma, não representam nenhuma empresa em particular.

Nesse trabalho, o interesse é modelar a probabilidade de um cliente cancelar o serviço contratado com o auxílio de variáveis auxiliares, desta forma, começamos com a análise exploratória do conjunto de dados, em seguida ajustamos o modelo de Cox e, por fim, ajustamos alguns modelos paramétricos usando as informações complementares dos clientes como regressoras.

O banco de dados usado pode ser encontrado no site:

\url{https://www.kaggle.com/blastchar/telco-customer-churn}

\pagebreak

# 2 - Análise exploratória dos dados

 O conjunto de dados utilizado consiste em $7.043$ observações de clientes de uma empresa de telecomunicações, sendo que a fonte dos dados não informou o nome da empresa em questão ou data de coleta dos dados, pois, de fato, os dados são artificiais. O conjunto contem $21$ variáveis que são descritas a seguir:

- **customeID**: Variável categórica na forma de uma sequência de $4$ números e $5$ letras separados por um traço (exemplo: *2155-AMQRX*), este valor é único para cada cliente (e portanto, para cada linha) e serve para identificar os clientes. Esta variável não foi usada no ajuste dos modelos.

- **gender**: Variável categórica binária representando o genêro do cliente, assume valores *Male* e *Female*.

- **SeniorCitizen**: Variável categórica binária, assume valor $1$ quando o cliente é idoso e $0$ caso contrário.

- **Partner**: Variável categórica binária, assume valores *Yes* e *No* indicando se o cliente possui parceiro.

- **Dependents**: Variável categórica binária, assume valores *Yes* e *No* indicando se o cliente possui dependentes.

- **tenure**: Variável contínua, assume apenas valores inteiros positivos e indica o número de meses desde a contratação do serviço por parte do cliente.

- **PhoneService**: Variável categórica binária, assume valores *Yes* e *No* indicando se o plano do cliente possui serviço de telefonia.

- **MultipleLines**: Variável categórica, assume valores *Yes*, *No* e *No phone service* indicando se o cliente contratou múltiplas linhas telefônicas.

- **InternetService**: Variável categórica, assume valores *DSL*, *Fiber optic*, *No* indicando o tipo de serviço de internet contratado.

- **OnlineSecurity**: Variável categórica, assume valores *Yes*, *No* e *No internet service* indicando se o cliente contratou o serviço de segurança *online* oferecido pela empresa.

- **OnlineBackup**: Variável categórica, assume valores *Yes*, *No* e *No internet service* indicando se o cliente contratou o serviço de *backup online* oferecido pela empresa.

- **DeviceProtection**: Variável categórica, assume valores *Yes*, *No* e *No internet service* indicando se o cliente contratou o serviço de proteção de dispositivos oferecido pela empresa.

- **TechSupport**: Variável categórica, assume valores *Yes*, *No* e *No internet service* indicando se o cliente contratou o serviço de suporte técnico oferecido pela empresa.

- **StreamingTV**: Variável categórica, assume valores *Yes*, *No* e *No internet service* indicando se o cliente contratou serviço de *Streaming* de TV.

- **StreamingMovies**: Variável categórica, assume valores *Yes*, *No* e *No internet service* indicando se o cliente contratou serviço de *Streaming* de filmes.

- **Contract**: Variável categórica, assume valores *Month-to-month*, *One year* e *Two year* indicando o tempo de vigência do contrato com a empresa.

- **PaperlessBilling**: Variável categórica binária, assume valores *Yes* e *No* indicando se o cliente recebe a cobrança da mensalidade por papel (*No*).

- **PaymentMethod**: Variável categórica, assume valores *Bank transfer (automatic)*, *Credit card (automatic)*, *Electronic check* e *Mailed check* indicando a forma de pagamento utilizada pelo cliente.

- **MonthlyCharges**: Variável contínua, assume valores valores positivos e indica o valor pago mensalmente pelo cliente.

- **TotalCharges**: Variável contínua, assume valores valores positivos e indica o valor pago pelo cliente do início do contrato até o momento da coleta dos dados.

- **Churn**: Variável categórica binária, assume valores *Yes* e *No* indicando se o cliente cancelou o serviço. No caso onde houve cancelamento, consideramos como falha, sendo que quando não houve cancelamento consideramos como censura tipo I (o cliente não havia cancelado até o momento da coleta).

Observe que há uma certa redundância entre as variáveis *MonthlyCharges* e *TotalCharges*, pois esta última seria a soma dos valores da mensalidade ao longo do tempo em que o cliente esteve na empresa, de fato, através de uma regressão linear, podemos verificar que *TotalCharges* pode ser quase perfeitamente descrito pelo produto entre *MonthlyCharges* e *tenure*, sendo que o coeficiente $R^2$ da regressão foi $99.91\%$, ou seja, $99.91\%$ da variabilidade de *TotalCharges* é explicada pelo produto entre *MonthlyCharges* e *tenure* (o coeficiente associado a ele é aproximadamente $1$). Vale ressaltar que a parcela da variabilidade não explicada se deve, provavelmente, a mudanças na mensalidade ao longo do tempo, a serviços com custo fixo contratados esporadicamente (uma taxa de manutenção) ou a algum tipo de taxa de adesão.

Segue adiante alguns gráficos com a distribuição das variáveis:

```{r fig.height=12, fig.width=8}
dados=read.csv('Telco-Customer-Churn.csv',stringsAsFactors = T)
dados=dados[order(dados$gender,
            dados$SeniorCitizen,
            dados$Partner,
            dados$Dependents,
            dados$PhoneService,
            dados$MultipleLines,
            dados$InternetService,
            dados$OnlineSecurity,
            dados$OnlineBackup,
            dados$DeviceProtection,
            dados$TechSupport,
            dados$StreamingTV,
            dados$StreamingMovies,
            dados$Contract,
            dados$PaperlessBilling,
            dados$PaymentMethod),]

dados$tenure=dados$tenure+0.5

ref_dat=as.data.frame(table(dados$gender))
ref_dat$group='gender'
ref_dat=ref_dat[order(ref_dat$Var1,decreasing =T),]
ref_dat$ypos=cumsum(ref_dat$Freq)-0.5*ref_dat$Freq
n=sum(ref_dat$Freq)
for(name in names(dados)[-c(1,2,6,19,20)]){
  dummy=as.data.frame(table(dados[[name]]))
  dummy$group=name
  
  dummy=dummy[order(dummy$Var1,decreasing =T),]
  dummy$ypos=cumsum(dummy$Freq)-0.5*dummy$Freq
  ref_dat=rbind(ref_dat,dummy)
}

#ref_dat=ref_dat[ref_dat$group=='gender',]
ref_dat$Var1=as.character(ref_dat$Var1)
ref_dat[ref_dat=='No internet service']='No internet<br>service'
ref_dat[ref_dat=='No phone service']='No phone<br>service'
ref_dat[ref_dat=='Bank transfer (automatic)']='Bank<br>transfer'
ref_dat[ref_dat=='Credit card (automatic)']='Credit<br>card'
ref_dat$Var1=as.factor(ref_dat$Var1)
  
  ggplot(ref_dat,
         aes(x='',
             fill=Var1,
             y=Freq))+
    geom_bar(width=10,stat='identity')+
    coord_polar('y',start=0)+
    geom_richtext(aes(y=ypos,
                  label = paste0('<b>',Var1,'</b>','<br>',100*round(Freq/n,4),'%')),
              color = "white",size=2,label.size=0,fill=NA) +
    scale_fill_hue(name)+
    facet_wrap(~group,ncol=4)+
    guides(fill='none')+
    theme_void()
```

\pagebreak


Apartir dos gráficos acima, podemos observar que há diversas categorias redundantes entre as variáveis, especificamente, as categorias *No internet service* representam sempre o mesmo grupo (o grupo representado pela categoria *No* da variável *InternetService*), sendo que algo semelhante acontece entre as variáveis *PhoneService* e *MultipleLines*. Para esse casos, podemos simplificar os modelos a serem ajustados omitindo o parâmetro associado a categoria *No internet service* (e *No phone service*), pois esta informação já está contida na variável *InternetService* (e *PhoneService*). Vale destacar que, caso a simplificação mencionada não fosse adotada, os paramêtros omitidos não seria estimados pelo *R* (apareceriam com valor $0$ e desvio padrão *NA*) e as demais estimativas seriam conservadas, desta forma, a simplicação adotada não tem efeito prático no ajuste dos modelos.

Ainda sobre a redundância entre as variáveis, foi observado que a mensalidade (*MonthlyCharges*) pode ser quase perfeitamente descrita como uma combinação linear (mais uma constante) das variáveis *PhoneService*, *MultipleLines*, *InternetService*, *OnlineSecurity*, *OnlineBackup*, *DeviceProtection*, *TechSupport*, *StreamingTV* e *StreamingMovies*, para ressaltar isto, ajustamos um modelo de regressão linear, onde obtemos um coeficiente $R^2$ igual a $99.88\%$, desta forma, seria redundante incluir nos modelo paramétricos a variável mensalidade junto as variávies associadas ao plano contratado, sendo então necessário verificar qual destes conjuntos de variáveis é mais significativo para o ajuste. Adiante temos um gráfico comparado os valores estimados da mensalidade usando o modelo de regressão linear e os valores observados:

```{r}
# Variáveis sem efeito signifiativo:
#    - gender
#    - SeniorCitizen
#    - Partner
#    - Dependents
#    - Contract
#    - PaperlessBilling
#    - PaymentMethod

regressao=
  lm(MonthlyCharges~PhoneService+MultipleLines+InternetService+
    OnlineSecurity+OnlineBackup+DeviceProtection+TechSupport+StreamingTV+StreamingMovies,
   data=dados)

ggplot()+
  geom_point(aes(x=dados$MonthlyCharges,y=regressao$fitted.values))+
  geom_line(aes(x=dados$MonthlyCharges,y=dados$MonthlyCharges),linetype='dashed')+
  scale_x_continuous('Mensalidade')+
  scale_y_continuous('Mensalidade estimada')+
  coord_fixed()+
  theme_bw()
```

Veja que os valores previstos são discretos, isso acontece devido ao fato de que todas as variáveis regressoras são categóricas. Vale observar também que a hipótese de homocedasticidade, necessária para o modelo de regressão linear, não parece ser respeitada, porém, para o escopo deste trabalho, isto não acarreta em problemas na análise, pois estamos interessados apenas em saber se a Mensalidade pode ser descrita como uma combinação linear de outras variáveis.

Por último, vale destacar que, ao se usar apenas a Mensalidade nos modelos paramétricos, há uma clara perda de informação, por isso, é necessário verificar se esta perda é significativa para o ajuste, pois caso não seja, pelo princípio da parcimônia, seria mais adequado usar o modelo mais simples, i.e., o modelo que usa a Mensalidade.

\textcolor{white}{Easter egg}

\pagebreak

# 3 - Ajuste de modelos paramétricos

Vamos agora fazer os nossos ajustes atravês do modelo paramétrico. Vamos tomar como os 3 posséveis modelos a Exponencial, Weibull e Log-normal e verificar a adequação de cada um dos modelos. Primeiramente vamos tomar o modelo completo (usando todas as covariáveis) em cada caso e aplicar o método de linearização das funções de sobrevivência para cada modelo e observar se elas estão aproximadamente linear.

Começando pelo modelo exponencial obtivemos o seguinte resultado:

```{r}
cens=ifelse(dados$Churn=='Yes',1,0)
tempos=as.numeric(dados$tenure)
#################################ajuste para os 3 possiveis modelos
####exponencial weibull log normal
ajust1 = survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                   dados$gender+dados$Partner+dados$Dependents+dados$PaymentMethod+dados$PaperlessBilling+
                   dados$MultipleLines+dados$PhoneService+dados$InternetService+dados$OnlineSecurity+
                   dados$OnlineBackup+dados$DeviceProtection+dados$TechSupport+dados$StreamingTV+
                   dados$StreamingMovies+dados$Contract,dist='exponential')#### 
alpha1 = exp(ajust1$coefficients[1])
ajust2 = survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                   dados$gender+dados$Partner+dados$Dependents+dados$PaymentMethod+dados$PaperlessBilling+
                   dados$MultipleLines+dados$PhoneService+dados$InternetService+dados$OnlineSecurity+
                   dados$OnlineBackup+dados$DeviceProtection+dados$TechSupport+dados$StreamingTV+
                   dados$StreamingMovies+dados$Contract,dist='weibull')
alpha2 = exp(ajust2$coefficients[1])
gama2 = 1/ajust2$scale
ajust3 = survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                   dados$gender+dados$Partner+dados$Dependents+dados$PaymentMethod+dados$PaperlessBilling+
                   dados$MultipleLines+dados$PhoneService+dados$InternetService+dados$OnlineSecurity+
                   dados$OnlineBackup+dados$DeviceProtection+dados$TechSupport+dados$StreamingTV+
                   dados$StreamingMovies+dados$Contract,dist='lognorm')
res=((dados$tenure)*exp(-ajust1$linear.predictors))^ajust1$scale
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()

  
```

Podemos observar que o modelo exponencial não se mostra como sendo o adequado para o nosso problema.

\pagebreak
Vamos agora fazer a mesma análise para o modelo Weibull.
```{r}
res=((dados$tenure)*exp(-ajust2$linear.predictors))^ajust2$scale
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

Também foi possivel de se observar uma não adequação do modelo, mas se comparada com o modelo exponencial já se percebe uma pequena melhora.

\pagebreak

Por fim, vamos fazer o mesmo processo de linearização da função de sobrevivência só que agora para o modelo log-normal.

```{r}
res=-log(1-pnorm((log(dados$tenure)-ajust3$linear.predictors)/ajust3$scale))#melhor 
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

Com isso podemos observar que o modelo com a Log-Normal, apesar de termos um certo desvio no final da reta, foi o modelo que melhor se ajustou e portanto todas as análises a seguir estarão seguindo o modelo paramétrico com a Log-Normal.

\pagebreak

Como visto anteriormente sabemos que existe uma redundância entre as variáveis, onde a mensalidade pode ser quase totalmente descrita por algumas das outras variaveis existentes no modelos (PhoneService, MultipleLines, InternetService, OnlineSecurity, OnlineBackup, DeviceProtection, TechSupport, StreamingTV e StreamingMovies) e com esta informação vamos optar por fazer o teste de dois possiveis ajustes e verificar qual deles está mais adequado. Nos próximos dois modelos também vão estar em ambos ajustes aquelas variaveis que não são relacionadas com mensalidade.

\vspace{50 pt}

Nosso primeiro ajuste leva em consideração a mensalidade:

```{r fig.height=4, fig.width=4}
ajustmensal=survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                      dados$gender+dados$Partner+dados$Dependents+dados$PaymentMethod+dados$PaperlessBilling+
                      dados$Contract,dist='lognormal')
ajustmensalnao=survreg(Surv(tempos+0.5,cens)~dados$gender+dados$Partner+dados$Dependents+dados$PaymentMethod+dados$PaperlessBilling+
                         dados$MultipleLines+dados$PhoneService+dados$InternetService+dados$OnlineSecurity+
                         dados$OnlineBackup+dados$DeviceProtection+dados$TechSupport+dados$StreamingTV+
                         dados$StreamingMovies+dados$Contract,dist='lognorm')
res=-log(1-pnorm((log(dados$tenure)-ajustmensal$linear.predictors)/ajustmensal$scale))#melhor 
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

\pagebreak

Já no segundo ajuste levamos em consideração os fatores que são capazes de descrever a mensalidade.

```{r fig.height=4, fig.width=4}
res=-log(1-pnorm((log(dados$tenure)-ajustmensalnao$linear.predictors)/ajustmensalnao$scale))#melhor
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()

```

\vspace{80 pt}

Com ambas as funções linearizadas podemos observar e constatar que o segundo ajuste está um pouco mais adequado e por isso vamos nos utilizar dos fatores que descrevem bem o valor pago de mensalidade ao invés de nos utilizarmos da mensalidade em si.

\pagebreak

Vamos agora tomar o nosso ajuste e através do modelo Backward e selecionar quais variáveis são significativas.

```{r fig.height=4, fig.width=4}
summary(ajustmensalnao)
ajustmensalnao=survreg(Surv(tempos+0.5,cens)~
                         dados$Partner+dados$PaymentMethod+
                         dados$MultipleLines+dados$InternetService+dados$OnlineSecurity+
                         dados$OnlineBackup+dados$DeviceProtection+dados$TechSupport+
                         dados$Contract,dist='lognorm')

```

Foi feito então o método de seleção *backward*, removendo uma variável não significativa de cada vez e recalculando o nosso modelo, até chegarmos no nosso modelo final onde nossas variáveis significativas são: tem ou não parceiro, métodos de pagamento, se possui múltiplas linhas de telefone, serviço de internet que o cliente possui, se o cliente possui serviço de segurança online, se possui backup, se possui serviço de proteção do telefone, suporte técnico e tipo de contrato.

```{r}
res=-log(1-pnorm((log(dados$tenure)-ajustmensalnao$linear.predictors)/ajustmensalnao$scale))#melhor
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

Podemos observar que o modelo possui uma quebra no começo e que também apresenta o que aparentam ser dois comportamentos distintos, um para o começo e outro mais para frente, e isso indica que talvez fosse interessante fazermos um modelo de mistura para analisar de forma separada cada um desses comportamentos.

\pagebreak

Por fim, vamos analisar agora os resíduos Martingale e os resíduos Deviance.

Resíduos Martingale:

```{r fig.height=3, fig.width=3}
cen=ifelse(dados$Churn=='Yes',1,0)
m=cen-res
d=sign(m)*sqrt(-2*(m+cen*log(cen-m)))
#m martigale d deviance
ggplot()+
  geom_point(aes(x=dados$tenure,y=m),alpha=0.1)+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

Resíduos Deviance:

```{r fig.height=3, fig.width=3}
ggplot()+
  geom_point(aes(x=dados$tenure,y=d),alpha=0.1)+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

Como a nossa quantidade de censuras é bem alta não é possivel identificarmos aquela distribuição aproximadamente Normal que os resíduos Deviance poderiam apresentar.

Por fim, o resultado do ajuste pode ser acessado em uma aplicação hospedada na núvem e disponível no link a seguir:

https://silvaneojunior.shinyapps.io/Reg_Surv/

\pagebreak

# 4 - Ajuste do modelo de Cox

Antes da parte de ajustar o modelo propriamente recomenda-se fortemente que alguns procedimentos sejam seguidos, sendo para isso útil explicitar a especificação do modelo com a finalidade de melhor entender os procedimentos que serão realizados posteriormente. Então sejam $\lambda$ a função de taxa de falha, $g$ uma função não negativa tal que $g(0) = 1$, $\lambda_{0}$ uma função não negativa do tempo, $\beta$ um vetor paramétrico e $x'_{i}$ um vetor de covariáveis para a $i$-ésima observação da amostra, pelo modelo de Cox, nós temos:

$$\lambda(t) = \lambda_{0}(t)g(x'_{i}\beta), \ \ \ \forall \ i \in \{1,\dots,n\}$$

Neste trabalho iremos adotar $g(x) = \exp\{x\}$. Dessa forma, obtemos que, para duas observações $i$ e $j$ quaisquer

$$\dfrac{\lambda_{i}(t)}{\lambda_{j}(t)} = \dfrac{\lambda_{0}(t)\exp\{x'_{i}\beta\}}{\lambda_{0}(t)\exp\{x'_{j}\beta\}} = \exp\{(x'_{i}-x'_{j})\beta\} = K(i,j)$$
Dessa relação, é possíveis extrair as principais hipóteses associadas ao modelo de Cox, sendo elas: a proporcianalidade dos riscos relativos e invariância do vetor paramétrico $\beta$ com relação ao tempo. Fica fácil de observar que essas condições precisam ser satisfeitas uma vez que, olhando para a função $\lambda_{i}(t)$, temos que toda a dependência temporal se deve à função $\lambda_{0}(t)$, que é comum à todas as observações. Assim, quando olhamos para a razão de quaisquer duas observações, sobra um termo que é constante supondo conhecidos o parâmetro $\beta$ e os vetores de covariáveis correspondentes.

Tendo as considerações acima em vista, vamos procurar fazer uma pré-seleção das variáveis com a finalidade de eleminar aquelas que apresentam cruzamentos das curvas detalhadas a seguir, servindo como um forte indicativo de violação da hipótese de proporcionalidade dos riscos. Seguem abaixo os gráficos das funções de taxa de falha acumuladas ajustadas para cada grupo de cada covariável de interesse contra o tempo. Vale ressaltar que foram realizados alguns agrupamentos entre certas categorias, por questões de similaridade ou de redundância da base de dados.

```{r}

dados_dwb <- read.csv(
  file = "Telco-Customer-Churn.csv",
  header = TRUE,
  sep = ",",
  quote = "",
  dec = "."
)

dados_dwb[which(dados_dwb[,8] == "No phone service"),8] <- "No"
for (j in c(10:15)){
  dados_dwb[which(dados_dwb[,j] == "No internet service"),j] <- "No"
}

dados_dwb[which(dados_dwb[,21] == "Yes"),22] <- 1
dados_dwb[which(dados_dwb[,21] == "No" ),22] <- 0
names(dados_dwb)[22] <- "Status" # Vale 1 no caso de falha e 0 no de censura

dados_dwb[,6] <- as.numeric(dados_dwb[,6])
dados_dwb[,6] <- dados_dwb[,6] + 0.5

for (i in 1:nrow(dados_dwb)){
  if (dados_dwb[i,18] %in% c("Bank transfer (automatic)", "Credit card (automatic)"))
    dados_dwb[i,18] <- "Automatic"
}

variables <- c(2:5, 7:18)
for (j in c(variables, 21)){
  dados_dwb[,j] <- as.factor(dados_dwb[,j])
}

aux_modelo_Nelson <- list()

for (k in 1:length(variables)){
  
  aux_modelo_Nelson[[k]] <- list()
  
  for (m in 1:length(table(dados_dwb[,variables[k]]))){
    
    aux_modelo_Nelson[[k]][[m]] <- 
      survfit(
        coxph(
          Surv(
            dados_dwb$tenure[which(dados_dwb[,variables[k]] == names(table(dados_dwb[,variables[k]]))[m])], 
            dados_dwb$Status[which(dados_dwb[,variables[k]] == names(table(dados_dwb[,variables[k]]))[m])]
          ) ~ 1,
          data = dados_dwb,
          x = T,
          method = "breslow"
        ), 
        conf.type = "log-log"
      )
  }
}

aux_nomes  <- list()
aux_nomes[[ 1]] <- c("Sexo", "Feminino", "Masculino")
aux_nomes[[ 2]] <- c("Sênior", "Não", "Sim")
aux_nomes[[ 3]] <- c("Parceiro", "Não", "Sim")
aux_nomes[[ 4]] <- c("Dependentes", "Não", "Sim")
aux_nomes[[ 5]] <- c("Serviço de Telefone", "Não", "Sim")
aux_nomes[[ 6]] <- c("Múltiplas Linhas", "Não", "Sim")
aux_nomes[[ 7]] <- c("Serviço de Internet", "DSL", "Fibra Óptica", "Não")
aux_nomes[[ 8]] <- c("Segurança Online", "Não", "Sim")
aux_nomes[[ 9]] <- c("Backup Online", "Não", "Sim")
aux_nomes[[10]] <- c("Proteção do Dispositivo", "Não", "Sim")
aux_nomes[[11]] <- c("Suporte Técnico", "Não", "Sim")
aux_nomes[[12]] <- c("Transmissão de TV", "Não", "Sim")
aux_nomes[[13]] <- c("Transmissão de Filmes", "Não", "Sim")
aux_nomes[[14]] <- c("Contrato", "Mês a Mês", "Anual", "Bienal")
aux_nomes[[15]] <- c("Cobrança Virtual", "Não", "Sim")
aux_nomes[[16]] <- c("Forma de Pagamento", 
                     "Automática",
                     "Cheque Eletrônico",
                     "Cheque por Correio")

aux_graph_Lambda <- list()

for (k in 1:length(variables)){
  
  aux <- ggplot() +
      scale_color_hue("") +
      scale_y_continuous(TeX("$log(\\Lambda(t))$")) +
      scale_x_continuous("Tempo em meses") +
      guides(fill = "none") +
      ggtitle(paste0("Log da Taxa de Falha Acumalada (",aux_nomes[[k]][1],")")) +
      theme_bw()
  
  for (m in 1:length(table(dados_dwb[,variables[k]]))){
    
    aux <- aux + 
      geom_step(
        aes_string(
          x = aux_modelo_Nelson[[k]][[m]]$time,
          y = log(-log(aux_modelo_Nelson[[k]][[m]]$surv)),
          color = paste0("'", aux_nomes[[k]][m+1], "'") 
        ), 
        lwd = 1.2
      )
  }
  aux_graph_Lambda[[k]] <- aux
}

```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[1]],
  aux_graph_Lambda[[2]],
  ncol = 2
)
  
```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[3]],
  aux_graph_Lambda[[4]],
  ncol = 2
)
  
```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[5]],
  aux_graph_Lambda[[6]],
  ncol = 2
)
  
```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[7]],
  aux_graph_Lambda[[8]],
  ncol = 2
)
  
```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[9]],
  aux_graph_Lambda[[10]],
  ncol = 2
)
  
```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[11]],
  aux_graph_Lambda[[12]],
  ncol = 2
)
  
```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[13]],
  aux_graph_Lambda[[14]],
  ncol = 2
)
  
```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot_grid(
  aux_graph_Lambda[[15]],
  aux_graph_Lambda[[16]],
  ncol = 2
)
  
```

Observando os gráficos acima, podemos notar que em alguns dos gráficos há cruzamento entra as curvas, evidenciando fortemente uma violação das hipóteses do modelo. Além disso, pela inspeção visual também é possível identificar variáveis pouco significativas. Sendo assim, a melhor alternativa seria desconsiderar tais variáveis para a seleção, nos limitando portanto a seguinte lista: SeniorCitizen, Partner, Dependents, InternetService, OnlineSecurity, OnlineBackup, DeviceProtection, TechSupport, Contract, PaperlessBilling, PaymentMethod. A partir destas foram selecionadas as variáveis a partir do método *backward*, no entanto o ajuste do modelo obtido foi insatisfatório na análise de resíduos, violando a hipótese de invariância dos coeficientes $\beta$'s ajustados com relação ao tempo.

Com a finalidade de resolver esse problema, foram então pré-selecionadas as variáveis que obtiveram um bom ajuste quando introduzidas individualmente no modelo e, a partir delas, foi realizado o método *forward*. As variáveis que obtiveram um ajuste adequado foram: Dependents, InternetService, PaperlessBilling e SeniorCitizen, sendo destas selecionadas apenas as três primeiras para o ajuste final. Para fins de esclarecimento da metodologia, segue abaixo o gráfico dos resíduos de Schoenfeld do modelo ajustado com uma covariável que não passou nessa etapa de pré-seleção:

```{r, fig.width = 6, fig.asp = 0.6, out.width = "50%", fig.align = 'center'}

modelo <- coxph(
  Surv(tenure, Status) ~ 
    Contract,
  data   = dados_dwb,
  x      = T,
  method = "breslow"
)

ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, y = cox.zph(modelo)$y), alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Contrato (Inadequado)") +
  theme_bw()

```

Agora segue a tabela contendo os coeficientes estimados seguidos das estatísticas obtidas para avaliar o nível de significância a partir do modelo final, contendo Dependents, InternetService e PaperlessBilling. Para a seleção do método *forward*, foi utilizado um nível de significância de $0,1\%$, uma vez que o conjunto de dados possui um número bem expressivo de observações, o que leva a uma facilidade grande de rejeição da hipótese nula nos testes que avaliar significância dos coeficientes.

```{r}

modelo <- coxph(
  Surv(tenure, Status) ~ 
    Dependents       +
    InternetService  +
    PaperlessBilling,
  data   = dados_dwb,
  x      = T,
  method = "breslow"
)

sobrev <- survfit(modelo)
coef   <- modelo$coefficients

kable_styling(
  kable(
    summary(modelo)$coefficients,
    format = "latex",
    align = "c",
    digits = 5,
    escape = FALSE,
    booktabs = TRUE,
    linesep = c("\\hline")
  ),
  position = "center",
  latex_options = "hold_position"
)

```

Pela tabela acima, é possível notar que todos os coeficientes se mostram significativos a um nível de $0,1\%$. Seguem abaixo os gráficos dos resíduos de martingale, deviance e Schoenfeld, para a validação do ajuste do modelo.

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot1 <- ggplot() +
  geom_point(aes(x = c(1:nrow(dados_dwb)), y = residuals(modelo, type = "martingale"), alpha = 0.1)) +
  scale_x_continuous("Índice") +
  scale_y_continuous("Resíduos") +
  ggtitle("Resíduos de Martingale") +
  theme_bw()

plot2 <- ggplot() +
  geom_point(aes(x = c(1:nrow(dados_dwb)), y = residuals(modelo, type = "deviance"), alpha = 0.1)) +
  scale_x_continuous("Índice") +
  scale_y_continuous("Resíduos") +
  ggtitle("Resíduos da Deviance") +
  theme_bw()

plot_grid(
  plot1,
  plot2,
  ncol = 2
)

```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot1 <- ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, y = cox.zph(modelo)[["y"]][,"Dependents"]), alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Dependentes") +
  theme_bw()

plot2 <- ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, y = cox.zph(modelo)[["y"]][,"InternetService"]), alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Serviço de Internet") +
  theme_bw()

plot_grid(
  plot1,
  plot2,
  ncol = 2
)

```

```{r, fig.width = 12, fig.asp = 0.3, out.width = "100%", fig.align = 'center'}

plot1 <- ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, y = cox.zph(modelo)[["y"]][,"PaperlessBilling"]), alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Cobrança Virtual") +
  theme_bw()

plot2 <- NULL

plot_grid(
  plot1,
  plot2,
  ncol = 2
)

```

Analisando os gráficos acima, é possível observar que, para os resíduos de martingale e da deviance não aparenta haver valores extremos, portanto não há a necessidade de remover observações e, quanto aos resíduos de Schoenfeld, todos aparentam possuir inclinação próxima de zero. A nível de completude, ainda é possível realizar testes de hipótese para avaliar se a inclinação é igual a zero, sendo que em todos os testes a hipótese foi rejeitada com um $p$-valor inferior a $10^{-16}$, entrando em conflito com a inspeção visual. Sendo assim, levando em consideração o tamanho da amostra, faz sentido priorizar a inspeção visual uma vez que os testes de hipótese se mostraram excessivamente sensíveis, resultando na conclusão de que o ajuste do modelo se encontra satisfatório.

A seguir, iremos mostrar as curvas ajustadas para todos as possíveis combinações de valores das covariáveis.

```{r, fig.width = 8, fig.asp = 0.7, out.width = "80%", fig.align = 'center'}

ggplot()+
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(0*coef[1] + 0*coef[2] + 0*coef[3] + 0*coef[4])), color = "(0, 0, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(0*coef[1] + 0*coef[2] + 0*coef[3] + 1*coef[4])), color = "(0, 0, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(0*coef[1] + 1*coef[2] + 0*coef[3] + 0*coef[4])), color = "(0, 1, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(0*coef[1] + 1*coef[2] + 0*coef[3] + 1*coef[4])), color = "(0, 1, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(0*coef[1] + 0*coef[2] + 1*coef[3] + 0*coef[4])), color = "(0, 2, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(0*coef[1] + 0*coef[2] + 1*coef[3] + 1*coef[4])), color = "(0, 2, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(1*coef[1] + 0*coef[2] + 0*coef[3] + 0*coef[4])), color = "(1, 0, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(1*coef[1] + 0*coef[2] + 0*coef[3] + 1*coef[4])), color = "(1, 0, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(1*coef[1] + 1*coef[2] + 0*coef[3] + 0*coef[4])), color = "(1, 1, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(1*coef[1] + 1*coef[2] + 0*coef[3] + 1*coef[4])), color = "(1, 1, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(1*coef[1] + 0*coef[2] + 1*coef[3] + 0*coef[4])), color = "(1, 2, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, y = sobrev$surv**(exp(1*coef[1] + 0*coef[2] + 1*coef[3] + 1*coef[4])), color = "(1, 2, 1)"), lwd = 1.2) +
  scale_color_hue("Grupo") +
  scale_y_continuous("S(t)") +
  scale_x_continuous("Tempo em meses") +
  guides(fill = "none") +
  ggtitle("Função de Sobrevivência") +
  theme_bw()
  
```

Pelo gráfico acima é possível notar que o modelo apresenta capacidade de gerar uma quantidade ampla de curvas de sobrevivência, tendo portanto capacidade pelo menos razoável de representa diferentes comportamentos presentes nas observações. A seguir, para finalizar esta parte, segue abaixo o gráfico contendo o valor estimado da exponencial dos coeficiente ajustados seguidos de seus intervlos de confiança.

```{r}

kable_styling(
  kable(
    summary(modelo)$conf.int,
    format = "latex",
    align = "c",
    digits = 5,
    escape = FALSE,
    booktabs = TRUE,
    linesep = c("\\hline")
  ),
  position = "center",
  latex_options = "hold_position"
)

```

Pela tabela acima, podemos concluir que a exponencial de todos os coeficientes é significativamente diferente de $1$, o que nos permite interpretar essas estatísticas, uma vez que o modelo satisfaz as hipóteses necessárias. Sendo assim, podemos utilizar a tabela acima para concluir que, supondo que as demais covariáveis são iguais, o risco relativo de cancelamente de um cliente com parceiros é metade do risco de cancelamento de um cliente sem parceiros. De forma análoga, sempre fixando as covariáveis não mencionadas, o risco de cancelamento para quem tem fibra ótica é quase o dobro do risco para quem não DSL, o risco de cancelamento para quem não tem serviço de internet é metade do risco de quem tem DSL e o risco de cancelamento para quem possui cobrança virtual é aproximadamente $1.3$ vez o risco de quem não possui.

\pagebreak

# 5 - Apêndice

\pagebreak

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
dados=read.csv('Telco-Customer-Churn.csv',stringsAsFactors = T)
dados=dados[order(dados$gender,
            dados$SeniorCitizen,
            dados$Partner,
            dados$Dependents,
            dados$PhoneService,
            dados$MultipleLines,
            dados$InternetService,
            dados$OnlineSecurity,
            dados$OnlineBackup,
            dados$DeviceProtection,
            dados$TechSupport,
            dados$StreamingTV,
            dados$StreamingMovies,
            dados$Contract,
            dados$PaperlessBilling,
            dados$PaymentMethod),]

dados$tenure=dados$tenure+0.5

ref_dat=as.data.frame(table(dados$gender))
ref_dat$group='gender'
ref_dat=ref_dat[order(ref_dat$Var1,decreasing =T),]
ref_dat$ypos=cumsum(ref_dat$Freq)-0.5*ref_dat$Freq
n=sum(ref_dat$Freq)
for(name in names(dados)[-c(1,2,6,19,20)]){
  dummy=as.data.frame(table(dados[[name]]))
  dummy$group=name
  
  dummy=dummy[order(dummy$Var1,decreasing =T),]
  dummy$ypos=cumsum(dummy$Freq)-0.5*dummy$Freq
  ref_dat=rbind(ref_dat,dummy)
}

#ref_dat=ref_dat[ref_dat$group=='gender',]
ref_dat$Var1=as.character(ref_dat$Var1)
ref_dat[ref_dat=='No internet service']='No internet<br>service'
ref_dat[ref_dat=='No phone service']='No phone<br>service'
ref_dat[ref_dat=='Bank transfer (automatic)']='Bank<br>transfer'
ref_dat[ref_dat=='Credit card (automatic)']='Credit<br>card'
ref_dat$Var1=as.factor(ref_dat$Var1)
  
  ggplot(ref_dat,
         aes(x='',
             fill=Var1,
             y=Freq))+
    geom_bar(width=10,stat='identity')+
    coord_polar('y',start=0)+
    geom_richtext(aes(y=ypos,
                  label = paste0('<b>',Var1,'</b>','<br>',
                                 100*round(Freq/n,4),'%')),
              color = "white",size=2,label.size=0,fill=NA) +
    scale_fill_hue(name)+
    facet_wrap(~group,ncol=4)+
    guides(fill='none')+
    theme_void()
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
# Variáveis sem efeito signifiativo:
#    - gender
#    - SeniorCitizen
#    - Partner
#    - Dependents
#    - Contract
#    - PaperlessBilling
#    - PaymentMethod

regressao=
  lm(MonthlyCharges~PhoneService+MultipleLines+InternetService+
    OnlineSecurity+OnlineBackup+DeviceProtection+TechSupport+
      StreamingTV+StreamingMovies,
   data=dados)

ggplot()+
  geom_point(aes(x=dados$MonthlyCharges,y=regressao$fitted.values))+
  geom_line(aes(x=dados$MonthlyCharges,y=dados$MonthlyCharges),
            linetype='dashed')+
  scale_x_continuous('Mensalidade')+
  scale_y_continuous('Mensalidade estimada')+
  coord_fixed()+
  theme_bw()
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
cens=ifelse(dados$Churn=='Yes',1,0)
tempos=as.numeric(dados$tenure)
#################################ajuste para os 3 possiveis modelos
####exponencial weibull log normal
ajust1 = survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                   dados$gender+dados$Partner+dados$Dependents+
                   dados$PaymentMethod+dados$PaperlessBilling+
                   dados$MultipleLines+dados$PhoneService+
                   dados$InternetService+dados$OnlineSecurity+
                   dados$OnlineBackup+dados$DeviceProtection+
                   dados$TechSupport+dados$StreamingTV+
                   dados$StreamingMovies+dados$Contract,
                 dist='exponential')#### 
alpha1 = exp(ajust1$coefficients[1])
ajust2 = survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                   dados$gender+dados$Partner+dados$Dependents+
                   dados$PaymentMethod+dados$PaperlessBilling+
                   dados$MultipleLines+dados$PhoneService+
                   dados$InternetService+dados$OnlineSecurity+
                   dados$OnlineBackup+dados$DeviceProtection+
                   dados$TechSupport+dados$StreamingTV+
                   dados$StreamingMovies+dados$Contract,
                 dist='weibull')
alpha2 = exp(ajust2$coefficients[1])
gama2 = 1/ajust2$scale
ajust3 = survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                   dados$gender+dados$Partner+dados$Dependents+
                   dados$PaymentMethod+dados$PaperlessBilling+
                   dados$MultipleLines+dados$PhoneService+
                   dados$InternetService+dados$OnlineSecurity+
                   dados$OnlineBackup+dados$DeviceProtection+
                   dados$TechSupport+dados$StreamingTV+
                   dados$StreamingMovies+dados$Contract,
                 dist='lognorm')
res=((dados$tenure)*exp(-ajust1$linear.predictors))^ajust1$scale
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')

  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
res=((dados$tenure)*exp(-ajust2$linear.predictors))^ajust2$scale
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
#melhor 
res=-log(1-pnorm((log(dados$tenure)-ajust3$linear.predictors)/ajust3$scale))
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
ajustmensal=survreg(Surv(tempos+0.5,cens)~dados$MonthlyCharges+
                      dados$gender+dados$Partner+dados$Dependents+dados$PaymentMethod+
                      dados$PaperlessBilling+
                      dados$Contract,dist='lognormal')
ajustmensalnao=survreg(Surv(tempos+0.5,cens)~dados$gender+ dados$Partner+ dados$Dependents+ dados$PaymentMethod+ dados$PaperlessBilling+
                         dados$MultipleLines+ dados$PhoneService+ dados$InternetService+ dados$OnlineSecurity+
                         dados$OnlineBackup+ dados$DeviceProtection+ dados$TechSupport+ dados$StreamingTV+
                         dados$StreamingMovies+ 
                         dados$Contract,dist='lognorm')
res=-log(1-pnorm(
  (log(dados$tenure)-ajustmensal$linear.predictors)/ajustmensal$scale)
)#melhor 
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
res=-log(1-pnorm(
  (log(dados$tenure)-ajustmensalnao$linear.predictors)/ajustmensalnao$scale)
  )#melhor
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
summary(ajustmensalnao)
ajustmensalnao=survreg(Surv(tempos+0.5,cens)~
                         dados$Partner+dados$PaymentMethod+
                         dados$MultipleLines+dados$InternetService+dados$OnlineSecurity+
                         dados$OnlineBackup+dados$DeviceProtection+dados$TechSupport+
                         dados$Contract,dist='lognorm')

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
res=-log(1-pnorm(
  (log(dados$tenure)-ajustmensalnao$linear.predictors)/ajustmensalnao$scale)
  )#melhor
kp_est=survfit(Surv(res,ifelse(dados$Churn=='Yes',1,0))~1)
compara=-log(kp_est$surv)
ggplot()+
  geom_point(aes(x=kp_est$time,y=compara),alpha=0.01)+
  geom_line(aes(x=c(min(kp_est$time,compara),max(kp_est$time,compara)),
                y=c(min(kp_est$time,compara),max(kp_est$time,compara))),
            linetype='dashed')+
  scale_x_continuous('')+
  scale_y_continuous('')
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
cen=ifelse(dados$Churn=='Yes',1,0)
m=cen-res
d=sign(m)*sqrt(-2*(m+cen*log(cen-m)))
#m martigale d deviance
ggplot()+
  geom_point(aes(x=dados$tenure,y=m),alpha=0.1)+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}
ggplot()+
  geom_point(aes(x=dados$tenure,y=d),alpha=0.1)+
  scale_x_continuous('')+
  scale_y_continuous('')+
  theme_bw()
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

dados_dwb <- read.csv(
  file = "Telco-Customer-Churn.csv",
  header = TRUE,
  sep = ",",
  quote = "",
  dec = "."
)

dados_dwb[which(dados_dwb[,8] == "No phone service"),8] <- "No"
for (j in c(10:15)){
  dados_dwb[which(dados_dwb[,j] == "No internet service"),j] <- "No"
}

dados_dwb[which(dados_dwb[,21] == "Yes"),22] <- 1
dados_dwb[which(dados_dwb[,21] == "No" ),22] <- 0
names(dados_dwb)[22] <- "Status" # Vale 1 no caso de falha e 0 no de censura

dados_dwb[,6] <- as.numeric(dados_dwb[,6])
dados_dwb[,6] <- dados_dwb[,6] + 0.5

for (i in 1:nrow(dados_dwb)){
  if (dados_dwb[i,18] %in% c("Bank transfer (automatic)", 
                             "Credit card (automatic)"))
    dados_dwb[i,18] <- "Automatic"
}

variables <- c(2:5, 7:18)
for (j in c(variables, 21)){
  dados_dwb[,j] <- as.factor(dados_dwb[,j])
}

aux_modelo_Nelson <- list()

for (k in 1:length(variables)){
  
  aux_modelo_Nelson[[k]] <- list()
  
  for (m in 1:length(table(dados_dwb[,variables[k]]))){
    
    aux_modelo_Nelson[[k]][[m]] <- 
      survfit(
        coxph(
          Surv(
            dados_dwb$tenure[
              which(dados_dwb[,variables[k]] == names(
                table(dados_dwb[,variables[k]]))[m])], 
            dados_dwb$Status[
              which(dados_dwb[,variables[k]] == names(
                table(dados_dwb[,variables[k]]))[m])]
          ) ~ 1,
          data = dados_dwb,
          x = T,
          method = "breslow"
        ), 
        conf.type = "log-log"
      )
  }
}

aux_nomes  <- list()
aux_nomes[[ 1]] <- c("Sexo", "Feminino", "Masculino")
aux_nomes[[ 2]] <- c("Sênior", "Não", "Sim")
aux_nomes[[ 3]] <- c("Parceiro", "Não", "Sim")
aux_nomes[[ 4]] <- c("Dependentes", "Não", "Sim")
aux_nomes[[ 5]] <- c("Serviço de Telefone", "Não", "Sim")
aux_nomes[[ 6]] <- c("Múltiplas Linhas", "Não", "Sim")
aux_nomes[[ 7]] <- c("Serviço de Internet", "DSL", "Fibra Óptica", "Não")
aux_nomes[[ 8]] <- c("Segurança Online", "Não", "Sim")
aux_nomes[[ 9]] <- c("Backup Online", "Não", "Sim")
aux_nomes[[10]] <- c("Proteção do Dispositivo", "Não", "Sim")
aux_nomes[[11]] <- c("Suporte Técnico", "Não", "Sim")
aux_nomes[[12]] <- c("Transmissão de TV", "Não", "Sim")
aux_nomes[[13]] <- c("Transmissão de Filmes", "Não", "Sim")
aux_nomes[[14]] <- c("Contrato", "Mês a Mês", "Anual", "Bienal")
aux_nomes[[15]] <- c("Cobrança Virtual", "Não", "Sim")
aux_nomes[[16]] <- c("Forma de Pagamento", 
                     "Automática",
                     "Cheque Eletrônico",
                     "Cheque por Correio")

aux_graph_Lambda <- list()

for (k in 1:length(variables)){
  
  aux <- ggplot() +
      scale_color_hue("") +
      scale_y_continuous(TeX("$log(\\Lambda(t))$")) +
      scale_x_continuous("Tempo em meses") +
      guides(fill = "none") +
      ggtitle(paste0("Log da Taxa de Falha Acumalada (",
                     aux_nomes[[k]][1],
                     ")")) +
      theme_bw()
  
  for (m in 1:length(table(dados_dwb[,variables[k]]))){
    
    aux <- aux + 
      geom_step(
        aes_string(
          x = aux_modelo_Nelson[[k]][[m]]$time,
          y = log(-log(aux_modelo_Nelson[[k]][[m]]$surv)),
          color = paste0("'", aux_nomes[[k]][m+1], "'") 
        ), 
        lwd = 1.2
      )
  }
  aux_graph_Lambda[[k]] <- aux
}

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[1]],
  aux_graph_Lambda[[2]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[3]],
  aux_graph_Lambda[[4]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[5]],
  aux_graph_Lambda[[6]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[7]],
  aux_graph_Lambda[[8]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[9]],
  aux_graph_Lambda[[10]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[11]],
  aux_graph_Lambda[[12]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[13]],
  aux_graph_Lambda[[14]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot_grid(
  aux_graph_Lambda[[15]],
  aux_graph_Lambda[[16]],
  ncol = 2
)
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

modelo <- coxph(
  Surv(tenure, Status) ~ 
    Contract,
  data   = dados_dwb,
  x      = T,
  method = "breslow"
)

ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, y = cox.zph(modelo)$y), 
             alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Contrato (Inadequado)") +
  theme_bw()

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

modelo <- coxph(
  Surv(tenure, Status) ~ 
    Dependents       +
    InternetService  +
    PaperlessBilling,
  data   = dados_dwb,
  x      = T,
  method = "breslow"
)

sobrev <- survfit(modelo)
coef   <- modelo$coefficients

kable_styling(
  kable(
    summary(modelo)$coefficients,
    format = "latex",
    align = "c",
    digits = 5,
    escape = FALSE,
    booktabs = TRUE,
    linesep = c("\\hline")
  ),
  position = "center",
  latex_options = "hold_position"
)

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot1 <- ggplot() +
  geom_point(aes(x = c(1:nrow(dados_dwb)), 
                 y = residuals(modelo, type = "martingale"), 
                 alpha = 0.1)) +
  scale_x_continuous("Índice") +
  scale_y_continuous("Resíduos") +
  ggtitle("Resíduos de Martingale") +
  theme_bw()

plot2 <- ggplot() +
  geom_point(aes(x = c(1:nrow(dados_dwb)), 
                 y = residuals(modelo, type = "deviance"), 
                 alpha = 0.1)) +
  scale_x_continuous("Índice") +
  scale_y_continuous("Resíduos") +
  ggtitle("Resíduos da Deviance") +
  theme_bw()

plot_grid(
  plot1,
  plot2,
  ncol = 2
)

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot1 <- ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, 
                 y = cox.zph(modelo)[["y"]][,"Dependents"]), 
             alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Dependentes") +
  theme_bw()

plot2 <- ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, 
                 y = cox.zph(modelo)[["y"]][,"InternetService"]), 
             alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Serviço de Internet") +
  theme_bw()

plot_grid(
  plot1,
  plot2,
  ncol = 2
)

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

plot1 <- ggplot() +
  geom_point(aes(x = cox.zph(modelo)$time, y = cox.zph(modelo)[["y"]][,"PaperlessBilling"]), alpha = 0.1) +
  scale_x_continuous("Tempo") +
  scale_y_continuous(TeX("$\\beta(t)$")) +
  ggtitle("Resíduos de Schoenfeld para Cobrança Virtual") +
  theme_bw()

plot2 <- NULL

plot_grid(
  plot1,
  plot2,
  ncol = 2
)

```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

ggplot()+
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(0*coef[1] + 0*coef[2] + 0*coef[3] + 0*coef[4])), 
                color = "(0, 0, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(0*coef[1] + 0*coef[2] + 0*coef[3] + 1*coef[4])), 
                color = "(0, 0, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(0*coef[1] + 1*coef[2] + 0*coef[3] + 0*coef[4])), 
                color = "(0, 1, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(0*coef[1] + 1*coef[2] + 0*coef[3] + 1*coef[4])), 
                color = "(0, 1, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(0*coef[1] + 0*coef[2] + 1*coef[3] + 0*coef[4])), 
                color = "(0, 2, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(0*coef[1] + 0*coef[2] + 1*coef[3] + 1*coef[4])), 
                color = "(0, 2, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(1*coef[1] + 0*coef[2] + 0*coef[3] + 0*coef[4])), 
                color = "(1, 0, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(1*coef[1] + 0*coef[2] + 0*coef[3] + 1*coef[4])), 
                color = "(1, 0, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(1*coef[1] + 1*coef[2] + 0*coef[3] + 0*coef[4])), 
                color = "(1, 1, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(1*coef[1] + 1*coef[2] + 0*coef[3] + 1*coef[4])), 
                color = "(1, 1, 1)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(1*coef[1] + 0*coef[2] + 1*coef[3] + 0*coef[4])), 
                color = "(1, 2, 0)"), lwd = 1.2) +
  geom_step(aes(x = sobrev$time, 
                y = sobrev$surv**(
                  exp(1*coef[1] + 0*coef[2] + 1*coef[3] + 1*coef[4])), 
                color = "(1, 2, 1)"), lwd = 1.2) +
  scale_color_hue("Grupo") +
  scale_y_continuous("S(t)") +
  scale_x_continuous("Tempo em meses") +
  ylim(0, 1) +
  guides(fill = "none") +
  ggtitle("Função de Sobrevivência") +
  theme_bw()
  
```

```{r echo = TRUE, results= 'hide', fig.show = 'hide', warning = FALSE}

kable_styling(
  kable(
    summary(modelo)$conf.int,
    format = "latex",
    align = "c",
    digits = 5,
    escape = FALSE,
    booktabs = TRUE,
    linesep = c("\\hline")
  ),
  position = "center",
  latex_options = "hold_position",
  font_size = 20
)

```
